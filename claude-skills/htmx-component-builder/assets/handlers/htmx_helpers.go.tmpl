// {{.PackageName}} - HTMX Helper Functions
// Generated by htmx-component-builder

package handlers

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

// HTMX Request Headers
const (
    HXRequest      = "HX-Request"
    HXTrigger      = "HX-Trigger"
    HXTriggerName  = "HX-Trigger-Name"
    HXTarget       = "HX-Target"
    HXCurrentURL   = "HX-Current-URL"
    HXPrompt       = "HX-Prompt"
)

// HTMX Response Headers
const (
    HXLocation    = "HX-Location"
    HXPushURL     = "HX-Push-Url"
    HXRedirect    = "HX-Redirect"
    HXRefresh     = "HX-Refresh"
    HXReplaceURL  = "HX-Replace-Url"
    HXReswap      = "HX-Reswap"
    HXRetarget    = "HX-Retarget"
    HXReselect    = "HX-Reselect"
    HXTriggerResp = "HX-Trigger"
)

// HTMXContext holds HTMX request information
type HTMXContext struct {
    IsHTMX       bool
    Trigger      string
    TriggerName  string
    Target       string
    CurrentURL   string
    Prompt       string
}

// GetHTMXContext extracts HTMX context from request
func GetHTMXContext(r *http.Request) HTMXContext {
    return HTMXContext{
        IsHTMX:      r.Header.Get(HXRequest) == "true",
        Trigger:     r.Header.Get(HXTrigger),
        TriggerName: r.Header.Get(HXTriggerName),
        Target:      r.Header.Get(HXTarget),
        CurrentURL:  r.Header.Get(HXCurrentURL),
        Prompt:      r.Header.Get(HXPrompt),
    }
}

// IsHTMXRequest checks if the request came from HTMX
func IsHTMXRequest(r *http.Request) bool {
    return r.Header.Get(HXRequest) == "true"
}

// TriggerEvent triggers a client-side event with optional data
func TriggerEvent(w http.ResponseWriter, eventName string, data interface{}) {
    if data == nil {
        w.Header().Set(HXTriggerResp, eventName)
        return
    }

    event := map[string]interface{}{
        eventName: data,
    }

    eventJSON, err := json.Marshal(event)
    if err != nil {
        w.Header().Set(HXTriggerResp, eventName)
        return
    }

    w.Header().Set(HXTriggerResp, string(eventJSON))
}

// TriggerMultipleEvents triggers multiple client-side events
func TriggerMultipleEvents(w http.ResponseWriter, events map[string]interface{}) {
    eventJSON, err := json.Marshal(events)
    if err != nil {
        return
    }

    w.Header().Set(HXTriggerResp, string(eventJSON))
}

// Redirect performs a client-side redirect
func Redirect(w http.ResponseWriter, url string) {
    w.Header().Set(HXRedirect, url)
}

// Refresh refreshes the entire page
func Refresh(w http.ResponseWriter) {
    w.Header().Set(HXRefresh, "true")
}

// PushURL updates the browser URL
func PushURL(w http.ResponseWriter, url string) {
    w.Header().Set(HXPushURL, url)
}

// ReplaceURL replaces the browser URL without adding to history
func ReplaceURL(w http.ResponseWriter, url string) {
    w.Header().Set(HXReplaceURL, url)
}

// Retarget changes the target element for the response
func Retarget(w http.ResponseWriter, selector string) {
    w.Header().Set(HXRetarget, selector)
}

// Reswap changes the swap strategy for the response
func Reswap(w http.ResponseWriter, strategy string) {
    w.Header().Set(HXReswap, strategy)
}

// Reselect selects a subset of the response HTML to swap
func Reselect(w http.ResponseWriter, selector string) {
    w.Header().Set(HXReselect, selector)
}

// Korean Date/Time Formatting

// FormatKoreanDate formats date in Korean style (2006년 1월 2일)
func FormatKoreanDate(t time.Time) string {
    return t.Format("2006년 1월 2일")
}

// FormatKoreanDateTime formats datetime in Korean style
func FormatKoreanDateTime(t time.Time) string {
    return t.Format("2006년 1월 2일 15시 04분")
}

// FormatKoreanRelativeTime formats time as relative Korean text
func FormatKoreanRelativeTime(t time.Time) string {
    now := time.Now()
    diff := now.Sub(t)

    switch {
    case diff < time.Minute:
        return "방금 전"
    case diff < time.Hour:
        return fmt.Sprintf("%d분 전", int(diff.Minutes()))
    case diff < 24*time.Hour:
        return fmt.Sprintf("%d시간 전", int(diff.Hours()))
    case diff < 30*24*time.Hour:
        return fmt.Sprintf("%d일 전", int(diff.Hours()/24))
    case diff < 365*24*time.Hour:
        return fmt.Sprintf("%d개월 전", int(diff.Hours()/(24*30)))
    default:
        return FormatKoreanDate(t)
    }
}

// FormatKoreanWeekday returns Korean weekday name
func FormatKoreanWeekday(t time.Time) string {
    weekdays := map[time.Weekday]string{
        time.Sunday:    "일요일",
        time.Monday:    "월요일",
        time.Tuesday:   "화요일",
        time.Wednesday: "수요일",
        time.Thursday:  "목요일",
        time.Friday:    "금요일",
        time.Saturday:  "토요일",
    }
    return weekdays[t.Weekday()]
}

// Korean Number Formatting

// FormatKoreanNumber formats number with commas
func FormatKoreanNumber(n int) string {
    if n < 0 {
        return "-" + FormatKoreanNumber(-n)
    }

    if n < 1000 {
        return fmt.Sprintf("%d", n)
    }

    return FormatKoreanNumber(n/1000) + "," + fmt.Sprintf("%03d", n%1000)
}

// FormatKoreanCount formats number with Korean counter (개)
func FormatKoreanCount(n int) string {
    return FormatKoreanNumber(n) + "개"
}

// FormatKoreanCurrency formats number as Korean Won
func FormatKoreanCurrency(amount int) string {
    return "₩" + FormatKoreanNumber(amount)
}

// FormatKoreanPercentage formats percentage
func FormatKoreanPercentage(value float64) string {
    return fmt.Sprintf("%.1f%%", value)
}

// Error Response Helpers

// ErrorResponse represents an error response
type ErrorResponse struct {
    Message string            `json:"message"`
    Fields  map[string]string `json:"fields,omitempty"`
}

// RenderHTMLError renders an HTML error message
func RenderHTMLError(w http.ResponseWriter, message string, statusCode int) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    w.WriteHeader(statusCode)

    html := fmt.Sprintf(`
        <div class="error-message korean-text">
            <span class="error-icon">❌</span>
            <span class="error-text">%s</span>
        </div>
    `, message)

    w.Write([]byte(html))
}

// RenderHTMLSuccess renders an HTML success message
func RenderHTMLSuccess(w http.ResponseWriter, message string) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")

    html := fmt.Sprintf(`
        <div class="success-message korean-text">
            <span class="success-icon">✅</span>
            <span class="success-text">%s</span>
        </div>
    `, message)

    w.Write([]byte(html))
}

// RenderJSONError renders a JSON error response
func RenderJSONError(w http.ResponseWriter, message string, statusCode int) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)

    errResp := ErrorResponse{
        Message: message,
    }

    json.NewEncoder(w).Encode(errResp)
}

// Validation Helpers

// ValidateSortField validates sort field against whitelist
func ValidateSortField(field string, validFields []string) string {
    for _, valid := range validFields {
        if field == valid {
            return field
        }
    }
    return validFields[0] // Return default (first field)
}

// ValidatePageNumber validates and normalizes page number
func ValidatePageNumber(pageStr string) int {
    page := 1

    if pageStr != "" {
        if p, err := parseInt(pageStr); err == nil && p > 0 {
            page = p
        }
    }

    return page
}

// ValidateLimit validates and normalizes limit with max
func ValidateLimit(limitStr string, defaultLimit, maxLimit int) int {
    limit := defaultLimit

    if limitStr != "" {
        if l, err := parseInt(limitStr); err == nil && l > 0 {
            limit = l
        }
    }

    if limit > maxLimit {
        limit = maxLimit
    }

    return limit
}

// parseInt safely parses string to int
func parseInt(s string) (int, error) {
    var n int
    _, err := fmt.Sscanf(s, "%d", &n)
    return n, err
}

// Middleware

// HTMXMiddleware adds HTMX detection to request context
func HTMXMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Add Vary header for caching
        if IsHTMXRequest(r) {
            w.Header().Set("Vary", HXRequest)
        }

        next.ServeHTTP(w, r)
    })
}

// CORSMiddleware adds CORS headers (if needed)
func CORSMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, "+HXRequest)

        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }

        next.ServeHTTP(w, r)
    })
}

// Template Function Map

// GetTemplateFuncs returns template functions for Korean formatting
func GetTemplateFuncs() map[string]interface{} {
    return map[string]interface{}{
        "formatKoreanDate":         FormatKoreanDate,
        "formatKoreanDateTime":     FormatKoreanDateTime,
        "formatKoreanRelativeTime": FormatKoreanRelativeTime,
        "formatKoreanWeekday":      FormatKoreanWeekday,
        "formatKoreanNumber":       FormatKoreanNumber,
        "formatKoreanCount":        FormatKoreanCount,
        "formatKoreanCurrency":     FormatKoreanCurrency,
        "formatKoreanPercentage":   FormatKoreanPercentage,
    }
}

// Example Usage in main.go:
/*
import (
    "html/template"
    "net/http"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"

    "your-project/handlers"
)

func main() {
    // Parse templates with Korean formatting functions
    templates := template.Must(
        template.New("").Funcs(handlers.GetTemplateFuncs()).ParseGlob("templates/*.html"),
    )

    // Initialize handlers
    contentRepo := // ... your repository
    contentHandler := handlers.NewContentHandler(contentRepo, templates)

    // Setup router
    r := chi.NewRouter()
    r.Use(middleware.Logger)
    r.Use(handlers.HTMXMiddleware)

    // Register routes
    handlers.RegisterContentRoutes(r, contentHandler)

    http.ListenAndServe(":8080", r)
}
*/
