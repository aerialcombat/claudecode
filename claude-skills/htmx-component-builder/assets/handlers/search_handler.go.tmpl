// {{.PackageName}} - Search Handler for HTMX Components
// Generated by htmx-component-builder

package handlers

import (
    "context"
    "html/template"
    "net/http"
    "strings"
    "time"
    "fmt"

    "github.com/go-chi/chi/v5"
)

// SearchRepository defines the interface for search operations
type SearchRepository interface {
    Search(ctx context.Context, query string, limit int) ([]SearchResult, error)
    SearchWithFilters(ctx context.Context, query string, filters SearchFilters, limit int) ([]SearchResult, error)
}

// SearchResult represents a search result item
type SearchResult struct {
    ID            int       `json:"id"`
    Title         string    `json:"title"`
    Excerpt       string    `json:"excerpt"`
    URL           string    `json:"url"`
    Source        string    `json:"source"`
    Thumbnail     string    `json:"thumbnail,omitempty"`
    PublishedAt   time.Time `json:"published_at"`
    FormattedDate string    `json:"formatted_date"`
}

// SearchFilters represents search filter options
type SearchFilters struct {
    Category string
    SortBy   string
    DateFrom time.Time
    DateTo   time.Time
}

// SearchHandler handles HTMX search requests
type SearchHandler struct {
    repo      SearchRepository
    templates *template.Template
}

// NewSearchHandler creates a new search handler
func NewSearchHandler(repo SearchRepository, templates *template.Template) *SearchHandler {
    return &SearchHandler{
        repo:      repo,
        templates: templates,
    }
}

// LiveSearch handles real-time search requests from HTMX
func (h *SearchHandler) LiveSearch(w http.ResponseWriter, r *http.Request) {
    query := strings.TrimSpace(r.URL.Query().Get("q"))

    // Empty query returns empty results
    if query == "" {
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Write([]byte(""))
        return
    }

    // Minimum length check (1 character is meaningful for Korean)
    if len([]rune(query)) < 1 {
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Write([]byte(`<div class="hint korean-text">검색어를 입력하세요</div>`))
        return
    }

    // Search database
    results, err := h.repo.Search(r.Context(), query, 20)
    if err != nil {
        h.renderError(w, "검색 중 오류가 발생했습니다", http.StatusInternalServerError)
        return
    }

    // Format dates for display
    for i := range results {
        results[i].FormattedDate = formatKoreanRelativeTime(results[i].PublishedAt)
    }

    data := map[string]interface{}{
        "Query":   query,
        "Results": results,
        "Count":   len(results),
    }

    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    if err := h.templates.ExecuteTemplate(w, "search-results", data); err != nil {
        h.renderError(w, "템플릿 렌더링 오류", http.StatusInternalServerError)
        return
    }
}

// SearchWithFilters handles search with filter options
func (h *SearchHandler) SearchWithFilters(w http.ResponseWriter, r *http.Request) {
    query := strings.TrimSpace(r.URL.Query().Get("q"))
    category := r.URL.Query().Get("category")
    sortBy := r.URL.Query().Get("sort")

    // Validate sort parameter (prevent SQL injection)
    validSorts := map[string]bool{
        "relevance":  true,
        "date":       true,
        "title":      true,
        "popularity": true,
    }

    if !validSorts[sortBy] {
        sortBy = "relevance"
    }

    filters := SearchFilters{
        Category: category,
        SortBy:   sortBy,
    }

    // Parse date filters if provided
    if dateFrom := r.URL.Query().Get("date_from"); dateFrom != "" {
        if t, err := time.Parse("2006-01-02", dateFrom); err == nil {
            filters.DateFrom = t
        }
    }

    if dateTo := r.URL.Query().Get("date_to"); dateTo != "" {
        if t, err := time.Parse("2006-01-02", dateTo); err == nil {
            filters.DateTo = t
        }
    }

    // Search with filters
    results, err := h.repo.SearchWithFilters(r.Context(), query, filters, 20)
    if err != nil {
        h.renderError(w, "검색 오류", http.StatusInternalServerError)
        return
    }

    // Format dates
    for i := range results {
        results[i].FormattedDate = formatKoreanRelativeTime(results[i].PublishedAt)
    }

    data := map[string]interface{}{
        "Query":    query,
        "Category": category,
        "SortBy":   sortBy,
        "Results":  results,
        "Count":    len(results),
    }

    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    h.templates.ExecuteTemplate(w, "search-results", data)
}

// Autocomplete provides search suggestions as user types
func (h *SearchHandler) Autocomplete(w http.ResponseWriter, r *http.Request) {
    query := strings.TrimSpace(r.URL.Query().Get("q"))

    if len([]rune(query)) < 2 {
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Write([]byte(""))
        return
    }

    // Get suggestions (limit to 5)
    results, err := h.repo.Search(r.Context(), query, 5)
    if err != nil {
        h.renderError(w, "자동완성 오류", http.StatusInternalServerError)
        return
    }

    data := map[string]interface{}{
        "Query":       query,
        "Suggestions": results,
    }

    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    h.templates.ExecuteTemplate(w, "autocomplete-results", data)
}

// renderError renders an error message
func (h *SearchHandler) renderError(w http.ResponseWriter, message string, statusCode int) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    w.WriteHeader(statusCode)

    data := map[string]string{
        "Message": message,
    }

    h.templates.ExecuteTemplate(w, "error", data)
}

// formatKoreanRelativeTime formats time in Korean relative format
func formatKoreanRelativeTime(t time.Time) string {
    now := time.Now()
    diff := now.Sub(t)

    switch {
    case diff < time.Minute:
        return "방금 전"
    case diff < time.Hour:
        return fmt.Sprintf("%d분 전", int(diff.Minutes()))
    case diff < 24*time.Hour:
        return fmt.Sprintf("%d시간 전", int(diff.Hours()))
    case diff < 30*24*time.Hour:
        return fmt.Sprintf("%d일 전", int(diff.Hours()/24))
    default:
        return t.Format("2006년 1월 2일")
    }
}

// RegisterSearchRoutes registers search routes with chi router
func RegisterSearchRoutes(r chi.Router, handler *SearchHandler) {
    r.Get("/api/search", handler.LiveSearch)
    r.Get("/api/search/filter", handler.SearchWithFilters)
    r.Get("/api/search/autocomplete", handler.Autocomplete)
}
