// {{.PackageName}} - Content Handler for HTMX Components
// Generated by htmx-component-builder

package handlers

import (
    "context"
    "encoding/json"
    "html/template"
    "net/http"
    "strconv"
    "time"

    "github.com/go-chi/chi/v5"
)

// ContentRepository defines the interface for content operations
type ContentRepository interface {
    GetByID(ctx context.Context, id int) (*Content, error)
    GetAll(ctx context.Context, offset, limit int) ([]Content, int, error)
    GetByTopic(ctx context.Context, topicSlug string, offset, limit int) ([]Content, int, error)
    Create(ctx context.Context, content *Content) (int, error)
    Update(ctx context.Context, id int, updates map[string]interface{}) error
    Delete(ctx context.Context, id int) error
}

// Content represents a content item
type Content struct {
    ID            int       `json:"id"`
    Title         string    `json:"title"`
    Excerpt       string    `json:"excerpt"`
    Content       string    `json:"content"`
    URL           string    `json:"url"`
    ImageURL      string    `json:"image_url,omitempty"`
    Source        string    `json:"source"`
    TopicSlug     string    `json:"topic_slug"`
    PublishedAt   time.Time `json:"published_at"`
    FormattedDate string    `json:"formatted_date"`
}

// ContentHandler handles HTMX content requests
type ContentHandler struct {
    repo      ContentRepository
    templates *template.Template
}

// NewContentHandler creates a new content handler
func NewContentHandler(repo ContentRepository, templates *template.Template) *ContentHandler {
    return &ContentHandler{
        repo:      repo,
        templates: templates,
    }
}

// GetContent retrieves a single content item
func (h *ContentHandler) GetContent(w http.ResponseWriter, r *http.Request) {
    idStr := chi.URLParam(r, "id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        h.renderError(w, "잘못된 ID입니다", http.StatusBadRequest)
        return
    }

    content, err := h.repo.GetByID(r.Context(), id)
    if err != nil {
        h.renderError(w, "콘텐츠를 찾을 수 없습니다", http.StatusNotFound)
        return
    }

    content.FormattedDate = formatKoreanRelativeTime(content.PublishedAt)

    // Check if HTMX request
    if isHTMXRequest(r) {
        // Return partial for HTMX
        h.renderTemplate(w, "content-detail-partial", content)
    } else {
        // Return full page for direct access
        h.renderTemplate(w, "content-detail-page", content)
    }
}

// LoadMore handles infinite scroll pagination
func (h *ContentHandler) LoadMore(w http.ResponseWriter, r *http.Request) {
    topicSlug := chi.URLParam(r, "slug")
    pageStr := r.URL.Query().Get("page")

    page, err := strconv.Atoi(pageStr)
    if err != nil || page < 1 {
        page = 1
    }

    perPage := 20
    offset := (page - 1) * perPage

    // Fetch content for topic
    items, total, err := h.repo.GetByTopic(r.Context(), topicSlug, offset, perPage)
    if err != nil {
        h.renderError(w, "콘텐츠를 불러올 수 없습니다", http.StatusInternalServerError)
        return
    }

    // Format dates
    for i := range items {
        items[i].FormattedDate = formatKoreanRelativeTime(items[i].PublishedAt)
    }

    hasMore := offset+perPage < total
    nextPage := page + 1

    data := map[string]interface{}{
        "Items":     items,
        "HasMore":   hasMore,
        "NextPage":  nextPage,
        "TopicSlug": topicSlug,
    }

    h.renderTemplate(w, "content-infinite-scroll", data)
}

// CreateContent creates a new content item
func (h *ContentHandler) CreateContent(w http.ResponseWriter, r *http.Request) {
    if err := r.ParseForm(); err != nil {
        h.renderError(w, "잘못된 요청입니다", http.StatusBadRequest)
        return
    }

    content := &Content{
        Title:     r.FormValue("title"),
        Content:   r.FormValue("content"),
        Source:    r.FormValue("source"),
        TopicSlug: r.FormValue("topic_slug"),
    }

    // Validate required fields
    if content.Title == "" {
        h.renderError(w, "제목은 필수입니다", http.StatusUnprocessableEntity)
        return
    }

    if content.Content == "" {
        h.renderError(w, "내용은 필수입니다", http.StatusUnprocessableEntity)
        return
    }

    // Create in database
    id, err := h.repo.Create(r.Context(), content)
    if err != nil {
        h.renderError(w, "저장 실패", http.StatusInternalServerError)
        return
    }

    content.ID = id
    content.FormattedDate = "방금 전"

    // Trigger custom event
    w.Header().Set("HX-Trigger", `{"contentCreated": {"id": `+strconv.Itoa(id)+`}}`)

    // Return new item HTML
    h.renderTemplate(w, "content-item", content)
}

// UpdateContent updates an existing content item
func (h *ContentHandler) UpdateContent(w http.ResponseWriter, r *http.Request) {
    idStr := chi.URLParam(r, "id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        h.renderError(w, "잘못된 ID입니다", http.StatusBadRequest)
        return
    }

    if err := r.ParseForm(); err != nil {
        h.renderError(w, "잘못된 요청입니다", http.StatusBadRequest)
        return
    }

    updates := map[string]interface{}{}

    if title := r.FormValue("title"); title != "" {
        updates["title"] = title
    }

    if content := r.FormValue("content"); content != "" {
        updates["content"] = content
    }

    if len(updates) == 0 {
        h.renderError(w, "수정할 내용이 없습니다", http.StatusBadRequest)
        return
    }

    err = h.repo.Update(r.Context(), id, updates)
    if err != nil {
        h.renderError(w, "수정 실패", http.StatusInternalServerError)
        return
    }

    // Fetch updated item
    content, err := h.repo.GetByID(r.Context(), id)
    if err != nil {
        h.renderError(w, "조회 실패", http.StatusInternalServerError)
        return
    }

    content.FormattedDate = formatKoreanRelativeTime(content.PublishedAt)

    // Trigger update event
    w.Header().Set("HX-Trigger", `{"contentUpdated": {"id": `+strconv.Itoa(id)+`}}`)

    h.renderTemplate(w, "content-item", content)
}

// DeleteContent deletes a content item
func (h *ContentHandler) DeleteContent(w http.ResponseWriter, r *http.Request) {
    idStr := chi.URLParam(r, "id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        h.renderError(w, "잘못된 ID입니다", http.StatusBadRequest)
        return
    }

    err = h.repo.Delete(r.Context(), id)
    if err != nil {
        h.renderError(w, "삭제 실패", http.StatusInternalServerError)
        return
    }

    // Trigger delete event
    w.Header().Set("HX-Trigger", `{"contentDeleted": {"id": `+idStr+`}}`)

    // Return 200 with empty body - HTMX will swap with empty (removes element)
    w.WriteHeader(http.StatusOK)
}

// GetModal loads content for modal display
func (h *ContentHandler) GetModal(w http.ResponseWriter, r *http.Request) {
    idStr := chi.URLParam(r, "id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        h.renderError(w, "잘못된 ID입니다", http.StatusBadRequest)
        return
    }

    content, err := h.repo.GetByID(r.Context(), id)
    if err != nil {
        h.renderError(w, "콘텐츠를 찾을 수 없습니다", http.StatusNotFound)
        return
    }

    content.FormattedDate = formatKoreanRelativeTime(content.PublishedAt)

    data := map[string]interface{}{
        "ID":      id,
        "Title":   content.Title,
        "Content": content.Content,
    }

    h.renderTemplate(w, "modal-container", data)
}

// renderTemplate renders a template with data
func (h *ContentHandler) renderTemplate(w http.ResponseWriter, templateName string, data interface{}) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")

    if err := h.templates.ExecuteTemplate(w, templateName, data); err != nil {
        http.Error(w, "템플릿 렌더링 오류: "+err.Error(), http.StatusInternalServerError)
    }
}

// renderError renders an error message
func (h *ContentHandler) renderError(w http.ResponseWriter, message string, statusCode int) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    w.WriteHeader(statusCode)

    data := map[string]string{
        "Message": message,
    }

    h.templates.ExecuteTemplate(w, "error", data)
}

// isHTMXRequest checks if request came from HTMX
func isHTMXRequest(r *http.Request) bool {
    return r.Header.Get("HX-Request") == "true"
}

// formatKoreanRelativeTime formats time in Korean relative format
func formatKoreanRelativeTime(t time.Time) string {
    now := time.Now()
    diff := now.Sub(t)

    switch {
    case diff < time.Minute:
        return "방금 전"
    case diff < time.Hour:
        return strconv.Itoa(int(diff.Minutes())) + "분 전"
    case diff < 24*time.Hour:
        return strconv.Itoa(int(diff.Hours())) + "시간 전"
    case diff < 30*24*time.Hour:
        return strconv.Itoa(int(diff.Hours()/24)) + "일 전"
    default:
        return t.Format("2006년 1월 2일")
    }
}

// RegisterContentRoutes registers content routes with chi router
func RegisterContentRoutes(r chi.Router, handler *ContentHandler) {
    r.Get("/api/content/{id}", handler.GetContent)
    r.Post("/api/content", handler.CreateContent)
    r.Put("/api/content/{id}", handler.UpdateContent)
    r.Delete("/api/content/{id}", handler.DeleteContent)

    r.Get("/api/topics/{slug}/content/more", handler.LoadMore)
    r.Get("/api/modal/{id}", handler.GetModal)
}
