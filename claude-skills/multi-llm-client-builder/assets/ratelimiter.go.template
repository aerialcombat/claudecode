package llm

import (
	"context"
	"sync"
	"time"
)

// RateLimiter implements a token bucket rate limiter
type RateLimiter struct {
	requestsPerMin int
	tokens         chan struct{}
	ticker         *time.Ticker
	mu             sync.Mutex
	closed         bool
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(requestsPerMin int) *RateLimiter {
	rl := &RateLimiter{
		requestsPerMin: requestsPerMin,
		tokens:         make(chan struct{}, requestsPerMin),
		ticker:         time.NewTicker(time.Minute / time.Duration(requestsPerMin)),
	}

	// Fill initial tokens
	for i := 0; i < requestsPerMin; i++ {
		rl.tokens <- struct{}{}
	}

	// Refill tokens periodically
	go func() {
		for range rl.ticker.C {
			select {
			case rl.tokens <- struct{}{}:
			default:
				// Buffer full, skip
			}
		}
	}()

	return rl
}

// Wait blocks until a token is available or context is cancelled
func (rl *RateLimiter) Wait(ctx context.Context) error {
	select {
	case <-rl.tokens:
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

// Close stops the rate limiter
func (rl *RateLimiter) Close() {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	if !rl.closed {
		rl.ticker.Stop()
		close(rl.tokens)
		rl.closed = true
	}
}
